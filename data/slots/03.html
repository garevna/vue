<style>
     h3 {
       text-align: center;
       margin: 15px 0;
       color: #829abd;
       font-size: 19px;
     }
</style>
<h3>Слоты с областью видимости</h3>

<p>Если слот содержит директиву <spec_words>bind</spec_words>,
то это слот с областью видимости</p>
<p>Директива <spec_words>bind</spec_words> автоматически создает область
видимости слота, доступную родителю, и помещает в эту область видимости те
локальные переменные дочернего компонента, которые указаны в директиве <spec_words>bind</spec_words></p>
<pre class="code-snippet">
&lt;slot name = "theData"
         :theClass = "figure"
         :theText = "Локальные данные компонента">
&lt;/slot>
</pre>
<p>Родитель может получить эти данные из <spec_words>scope</spec_words> дочернего компонента
через алиас, который устанавливается атрибутом <spec_words>slot-scope</spec_words></p>
<pre class="code-snippet">
&lt;div slot = "theData"
        slot-scope = "theDataScope"
        :class = "theDataScope.theClass">
      {{ theDataScope.theText }}
&lt;/div>
</pre>
<p>Таким образом, родитель может выводить внутри своей 'капсюлы' свои данные вперемешку с данными компонента</p>
<p>Он может использовать внутри своей 'капсюлы' и свои стили, и стили компонента</p>
<p>Он может получить сообщение из дочернего компонента, например, инфо о его текущем состоянии...</p>
<p>Как вы будете использовать слоты с областью видимости - это ваше дело, но это реально прикольная штука</p>
<h3>Внимание</h3>
<p>Слоты с областью видимости следует искать не в свойстве <spec_words>$slots</spec_words>,
а в свойстве <spec_words>$scopedSlots</spec_words> компонента</p>
<p>Например, если в дочернем компоненте есть слот</p>
<pre class="code-snippet">
&lt;slot name = "button-picture"
      :theClass = "buttonPictureClass">
&lt;/slot>
</pre>
<p>то можно вывести его в консоль таким образом</p>
<pre class="code-snippet">
    console.log ( this.$scopedSlots [ "button-picture" ] )
</pre>
<h3>Лирическое описание</h3>
<p>Традиционно слоты используются для размещения контента родителя внутри потомка</p>
<p>Именованные слоты позволяют это делать виртуозно - с точным попаданием в нужное место потомка</p>
<p>Однако при этом и родитель, и потомок по-прежнему жутко одиноки в своих scope, и не могут разделить
друг с другом свои пирожки и варенье...</p>
<p>Очевидно, грусть от этого одиночества и затворничества стали причиной появления scoped slots - разрушителей
стен между отцами и детьми</p>
<p>Что происходит?</p>
<p>Родитель получает ограниченный доступ к scope потомка</p>
<p>Как?</p>
<p>Через атрибут <spec_words>slot-scope</spec_words>:</p>
<pre class="code-snippet">
&lt;child-component>
    &lt;p slot-scope = "textSlotScope"
        slot = "the-text">
    &lt;/p>
&lt;/child-component>
</pre>
<p>Итак, родитель со своей стороны сделал шаг навстречу и раскрыл объятия ( или приготовил ремень для порки? )</p>
<p>Он вставил внутрь тега дочернего компонента <var_names>&lt;child-component>&lt;/child-component></var_names>
элемент с атрибутом <spec_words>slot-scope</spec_words>, что означает "грузи сюда" (или "покажи дневник"? )</p>
<p>Теперь ему доступен контент области видимости потомка через алиас <var_names>textSlotScope</var_names></p>
<p>Однако нужно еще знать, что там, у детеныша, есть, чем можно поживиться</p>
<p>Не все, ох, не все готов показать папашке сынуля...</p>
<p>увидит предок только то, что прибиндил детеныш в теге <spec_words>slot</spec_words>:</p>
<pre class="code-snippet">
&lt;slot name = "the-text"
      :theAwards = "thePositiveInfoAboutMe">
&lt;/slot>
</pre>
<p>В данном случае - награды и поощрения, которые и может теперь посмотреть папочка следующим образом:</p>
<pre class="code-snippet">
     textSlotScope.theAwards
</pre>
<p>Иными словами, преимущество на стороне ребенка:</p>
<p>сколько алиасов ни вешай родитель, если чайлд не прибиндит что-то для него, то будет предку индейская хижина...</p>
