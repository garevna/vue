<style>
    p, li { font-size: 13px; }
    ul.simple {
      background-color: transparent!important;
      margin-left: 25px;
    }
</style>
<p>Промис - это объект-администратор асинхронного процесса</p>

<p>Создается с помощью конструктора <spec_words>Promise</spec_words></p>
<p>Администратор сам ничего не делает, но координирует работу исполнителей</p>
<p>Он ничего не знает о процессе, который администрирует, но знает порядок вызова
исполнителей</p>
<p>Ему нужно просто указать исполнителей</p>
<p>Исполнители - это функции</p>
<br>
<p>Предположим, вам выслали бандероль</p>
<p>"Новая почта" - функция, которая выполняет доставку бандероли</p>
<p>Она может доставить нам бандероль, а может потерять ( испортить ) отправление</p>
<p>Мы ждем доставку бандероли</p>
<p>Но при этом жизнь не останавливается, и мы не сидим день и ночь на ступеньках
отделения "Новой почты"</p>
<p>Мы создаем промис</p>
<p>Передаем ему функцию-исполнителя ( <var_names>"Новая почта"</var_names> )</p>
<p>Самой функции-исполнителю мы сообщаем, что делать в случае завершения процесса
доставки</p>
<ul class = "simple">
<li>если бандероль благополучно доставлена, то первый коллбэк (наш сосед дядя Вася)
зайдет получить ее</li>
<li>если бандероль потерялась или испорчена, то второй коллбэк (наш адвокат)
займется этой проблемой</li>
</ul>

<pre class = "code-snippet">
    var wrapper = new Promice ( Новая почта ( receiver, advocate ) )
</pre>

<p>Итак, исполнитель первого уровня ( <var_names>"Новая почта"</var_names> )
уже передан промису</p>
<p>Этот исполнитель ничего не знает об исполнителях второго уровня</p>
<p>Он знает, что таковые должны быть, и для него они - формальные параметры
<var_names>receiver</var_names> и <var_names>advocate</var_names></p>
<p>Он вызывает <var_names>receiver</var_names> или <var_names>advocate</var_names>
в своем коде, не вникая в их личности</p>
<p>Зато промис <var_names>wrapper</var_names> как администратор должен знать каждого исполнителя</p>
<p>Оба коллбэка ( точнее, их телефоны ) передаются промису <var_names>wrapper</var_names>
через его свойства <spec_words>then</spec_words> (<spec_words>catch</spec_words>)</p>
<pre class = "code-snippet">
    wrapper.then ( сосед дядя Вася )
           .catch ( адвокат Тимофей Иванович )
</pre>
<p>можно и так</p>
<pre class = "code-snippet">
    wrapper.then ( сосед дядя Вася )
           .then ( адвокат Тимофей Иванович )
</pre>

<p>Таким образом, созданный нами промис - это объект, в который мы "завернули" процесс
доставки-получения бандероли, расписав исполнителей, чтобы больше не заморачиваться</p>

<p>Итак, промис</p>
<ul class = "simple">
<li>всегда связан с каким-то асинхронным процессом ( например, <spec_words>AJAX</spec_words> )</li>
<li>пока процесс не завершен, промис находится в состояни ожидания</li>
<li>процесс запускает функция, которая передается промису в качестве параметра</li>
<li>после завершения процесса функция передает управление одному из двух коллбэков,
   которые являются ее формальными параметрами</li>
<li>первый коллбэк запускается, когда процесс завершен успешно</li>
<li>второй коллбэк запускается, если процесс завершается неудачей</li>
<li>фактические исполнители второго уровня (коллбэки) передаются промису уже после
его создания через его свойство <spec_words>then</spec_words>
( аналогично тому, как мы передаем обработчиков событий элементов DOM через
свойства <spec_words>onclick</spec_words>, <spec_words>onmousemove</spec_words> и т.д.)</li>
</ul>

<pre>
</pre>

<h3>Пример создания Promise:</h3>
<pre class = "code-snippet">
var promise = new Promise( ( resolve, reject ) => {
    var transport = new XMLHttpRequest ()
    transport.onreadystatechange = function () {
        var mess = transport.responseText
        if ( transport.readyState === 4 ) {
            if ( transport.status === 200 )
                resolve ( transport.responseText )
            else reject ( transport.responseText )
        }
    }
    transport.open ( "GET", sourceURL )
    transport.send ()
})
</pre>
<p>Для навешивания обработчиков:</p>
<pre class = "code-snippet">
promise.then ( success, failure )
</pre>
<ul class = "simple">
<li><var_names>success</var_names> – функция, которая будет вызвана при обращении к resolve
с передачей ей результата операции</li>
<li><var_names>failure</var_names> – функция, которая будет вызвана при обращении к reject
с передачей ей ошибки</li>
</ul>
<p>Поскольку коллбэки <var_names>success</var_names> и <var_names>failure</var_names>
являются, как правило, одноразовыми, нет особого смысла захламлять свой код объявлением
лишних именованных функций</p>
<p>Вместо этого можно использовать безымянные коллбэки, которые навешиваются
промису так</p>
<pre class = "code-snippet">
promise.then ( result => {
     document.write ( result )
})
.then ( err => {
     console.log ( err )
})
</pre>
