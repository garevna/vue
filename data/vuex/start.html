<p>Ядром любого Vuex-приложения явлется реактивный объект, 
создать который можно с помощью конструктора Vuex.Store:</p>
<pre class="code-snippet">
const store = new Vuex.Store({
  state: {
    currentCounterValue:  0,
    previousCounterValue: 0,
  },
  mutations: {
    nextPicture: state => { ... },
    previousPicture: state => { ... }
  }
})
</pre>
<p>Он хранит состояние приложения</p>

<p>Реактивные данные объекта store находятся в свойстве <b>state</b></p>
<p>Изменение реактивных данных состояния (state) приведет к 
изменениям во всех компонентах модели</p>

<p>Именно поэтому изменения состояния этого объекта называют 
  <i>мутациями</i> (<b>mutations</b>), а не методами</p>

<p>Мутации являются синхронными операциями</p>
<p>Они подобны обработчикам событий</p>

<p>Вызвать мутацию (измененить состояние объекта store) можно 
  с помощью метода <b>commit</b></p>

<p>Параметром метода commit будет любая мутация из 
описанных в свойстве mutations:</p>
<pre class="code-snippet">
methods: {
    gotoNext: () => store.commit('nextPicture'),
    gotoPrevious: () => store.commit('previousPicture'),
  }
</pre>

<p>Доступ к глобальному объекту store, а, следовательно,
  к его состоянию <b font-size="18px">store.state</b> возможен из любого компонента</p>
<pre class="code-snippet">
computed: {
    img: () => 
      store.state.pictures [ store.state.currentCounterValue ],
  }
</pre>
<p>При этом в компонентах нужно создавать вычисляемые свойства 
(computed), чтобы все мутации объекта store (изменения его 
состояния) реактивно отражались в компонентах.</p>

<p>Любой компонент может вызвать мутацию store с помощью метода 
commit:</p>
<pre class="code-snippet">
methods: {
    gotoNext: () => store.commit ( 'nextPicture' ),
    gotoPrevious: () => store.commit ( 'previousPicture' ),
}
</pre>
