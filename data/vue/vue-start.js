var items = [
    {
        header: "Модель и DOM",
        content: `
          <p>Если вы хорошо знаете JavaScript, то вам наверняка приходилось делать следующее</p>
          <pre class = "snippet">
             var elem = document.querySelector ( '#picture' )
             elem.parentNode.removeChild ( elem )
          </pre>
          <p>или</p>
          <pre class = "snippet">
             var elem = document.createElement ( 'div' )
             document.body.appendChild ( elem )
          </pre><br>
          <p>Это манипуляции с реальным DOM</p>
          <p>Все элементы DOM с точки зрения JS являются объектами с унаследованными от прототипа свойствами, событиями и методами.
          Поэтому мы можем манипулировать элементами DOM, создавать их, вставлять и удалять, изменять значения их свойств, добавлять методы, навешивать обработчиков событий, создавать события...</p>
          <p>В результате получаются динамические страницы, не требующие перезагрузки при изменении содержимого</p>
          <p>Это называется приложение одной страницы, или Single Page Application (<spec_words>SPA</spec_words>)</p>
        `
    },
    {
        header: "Single Page Application",
        content: `
          <p>В чем суть <spec_words>SPA</spec_words>?</p>
          <p>Есть модель, где царствует JS, есть реальный DOM, где хозяйничает браузер, и есть механизм, связывающий модель с DOM, опять-таки JS-код, осуществляющий манипуляции с DOM с помощью методов объекта <spec_words>document</spec_words></p>
          <p>Создание такого приложения - трудоемкий процесс. Хорошо, если нам удалось отделить логику модели от механизма отображения изменений в DOM. В противном случае можно заблудиться в дебрях кода</p>
          <p>Модель данных специфична для каждого приложения, однако механизм отображения изменений в DOM - это рутинная работа</p>
          <p>Вот эту работу и берет на себя Vue</p>
          <p>Подключив его к своему приложению, мы избавляем себя от необходимости манипулировать реальным DOM</p>
          <p>Мы можем сосредоточиться на модели, манипуляциях с данными, а реактивная система Vue обеспечивает обновление DOM при изменении данных модели</p>
          <p>При этом Vue использует еще одну ( промежуточную ) модель - виртуальный DOM</p>
          <p>Все изменения в нашей модели "накапливаются" в виртуальном DOM, и "пакетом" отображаются в реальный DOM на очередном "тике" обновления</p>
          <p>Это позволяет избежать побочных эффектов слишком частотого обновления страницы</p>
          <p>Отсюда следует, что если мы напрямую "вламываемся" в реальный DOM, то сделанные нами изменения не отобразятся в виртуальном DOM, контролируемом Vue</p>
          <p>Реактивная система Vue не будет знать о наших манипуляциях</p>
          <p>Есть риск, что на следующем тике обновления страницы сделанные нами изменения будут аннулированы</p>
          <p>Поэтому корректный способ действий с нашей стороны - ограничиться манипуляциями с моделью, предоставив Vue работу с представлением (DOM)</p>
        `
    },
    {
      header: "Экземпляр Vue",
      content: `
        <p>Каркасом модели является экземпляр Vue. Само слово "экземпляр" наводит нас на мысль о классе объектов и конструкторе класса. И эта мысль верна</p>
        <p>Конечно, Vue и плагины для Vue, которые мы будем изучать позже, предоставляют нам конструкторы для создания объектов определенного класса</p>
        <p>Сейчас мы используем конструктор для создания экземпляра класса Vue:</p>
        <pre class = "snippet">
           const sampleVue = new Vue  ({
           })
        </pre>
        <p>Как мы видим, конструктору передается объект входных параметров, пока пустой</p>
        <p>Но созданный объект <var_names> sampleVue </var_names> уже имеет унаследованные свойства и методы прототипа <spec_words>Vue</spec_words></p>
        <p>Если вывести в консоль объект <var_names>sampleVue</var_names>, то мы увидим длинный перечень этих свойств и методов</p>
        <p>Модель мы уже создали. Однако, во-первых, в модели нет данных, а во-вторых, она не связана с DOM. Это означает, что наши манипуляции с моделью никак не отобразятся на веб-странице</p>
      `
    },
    {
      header: "Точка монтирования",
      content: `
      <p>У экземпляра Vue есть унаследованное свойство <spec_words>el</spec_words>, значение которого является ссылкой на <spec_words>точку монтирования</spec_words> экземпляра, т.е. элемент DOM, с которым будет связана модель</p>
      <p>Мы можем создать точку монтирования в разметке:</p>
      <pre class = "snippet">
         &lt;body>
             &lt;div id = "sample">&lt;/div>
         &lt;/body>
      </pre>
      <p>и связать нашу модель с элементом DOM, имеющим <spec_words>id</spec_words> = <var_names>sample</var_names></p>
      <pre class = "snippet">
         const sampleVue = new Vue  ({
             el: '#sample'
         })
      </pre>
      <p>Теперь реактивная система Vue знает, куда должна отображаться наша модель</p>
      <p>У экземпляра Vue есть также унаследованный метод <spec_words>$mount</spec_words>, который делает то же самое - связывает нашу модель с точкой монтажа ( элементом DOM )</p>
      <pre class = "snippet">
         const sampleVue = new Vue  ({

         }).$mount ( '#sample' )
      </pre>
      <p>Метод <spec_words>$mount</spec_words> определяет значение свойства <spec_words>el</spec_words></p>
      `
    },
    {
      header: "Реактивные данные",
      content: `
      <p>У  экземпляра Vue есть унаследованные свойства <spec_words>data</spec_words> и <spec_words>computed</spec_words></p>
      <p>Это объекты, в которых хранятся реактивные данные модели</p>
      <pre class = "snippet">
         const sampleVue = new Vue  ({
             data: {
               ...
             },
             computed: {
               ...
             }
         }).$mount ( '#sample' )
      </pre>
      <p>Реактивные данные - это данные, изменение которых отслеживается реактивной системой Vue</p>
      <p>Когда значения переменных, объявленных в свойстве <spec_words>data</spec_words> или в свойстве <spec_words>computed</spec_words>, изменяются,
      реактивная система Vue фиксирует эти изменения в виртуальном DOM</p>
      <p>На очередном тике обновления все зафиксированные изменения будут отражены в реальном DOM</p>
      <p>Таким образом, если какие-то данные должны реактивно отображаться на странице, они должны быть предварительно объявлены в свойстве <spec_words>data</spec_words> или <spec_words>computed</spec_words></p>
      `
    },
    {
      header: "Вывод данных модели. 'Усатый' синтаксис",
      content: `
          <p>Предположим, что в объекте <spec_words>data</spec_words> экземпляра Vue объявлено свойство <var_names>message</var_names>, которое будет динамически обновляться в процессе работы приложения</p>
          <pre class = "snippet">
             const sampleVue = new Vue  ({
                 data: {
                   message: "Четверг"
                 }
             }).$mount ( '#sample' )
          </pre>
          <p>Вывести на страницу значение свойства <var_names>message</var_names> можно с помощью "усатого" синтаксиса:</p>
          <pre class = "snippet">
             &lt;body>
                 &lt;div id = "sample">
                    {{ message }}
                 &lt;/div>
             &lt;/body>
          </pre>
          <p>Поскольку <var_names>message</var_names> объявлено в реактивном объекте <spec_words>data</spec_words>, изменение значения переменной <var_names>message</var_names> будет реактивно отображаться на странице</p>
      `
    }
]
